# Motion Tracking Suit Project Documentation

## Table of Contents
1. [Introduction](#introduction)
   - 1.1 Overview
   - 1.2 Project Components
   - 1.3 Features
2. [Installation](#installation)
   - 2.1 Required Libraries
   - 2.2 Hardware Setup
   - 2.3 Software Setup
3. [Arduino Code](#arduino-code)
   - 3.1 Sensor Configuration
   - 3.2 WiFi and UDP Configuration
   - 3.3 Kalman Filter Setup
   - 3.4 Magnetometer Calibration
4. [Sensor Data Update](#sensor-data-update)
   - 4.1 Updating Sensor Data
   - 4.2 Updating MPU6050 Sensor Data
   - 4.3 Updating HMC5883L Sensor Data
   - 4.4 Setting Motion Detection Threshold and Duration for MPU6050
   - 4.5 Enabling Motion Interrupt for MPU6050
   - 4.6 Initializing Kalman Filter Angles (kalAngleX, kalAngleY, kalAngleZ)
5. [UDP Data Sending](#udp-data-sending)
   - 5.1 JSON Data Serialization (sensorGetJson())
   - 5.2 Sending UDP Data (udpSend())
6. [User Interface in Blender](#user-interface-in-blender)
   - 6.1 Blender Plugin Overview
   - 6.2 Server Configuration Panel (SERMOTIONS_PT_server)
   - 6.3 Blender Operators for Start and Save (OT_start, OT_save)
   - 6.4 Blender Panel Registration (register(), unregister())
7. [Main Function and Execution](#main-function-and-execution)
   - 7.1 Plugin Registration (register(), unregister())
   - 7.2 Main Execution for Blender Plugin
8. [Unreal Engine Integration](#unreal-engine-integration)
   - 8.1 Overview
   - 8.2 Installing the Plugin
   - 8.3 Configuring Motion Tracking Suit
   - 8.4 Usage and Integration with Unreal Engine
9. [Folder Structure](#folder-structure)
10. [Conclusion](#conclusion)
   - 10.1 Summary
   - 10.2 Acknowledgments
   - 10.3 License
   - 10.4 Contact Information

## 1. Introduction

### 1.1 Overview
The Motion Tracking Suit project is a system that tracks motion using Arduino-based sensors and visualizes the data in Blender. It offers a practical solution for motion tracking in various applications, including animation, game development, and virtual reality experiences.

### 1.2 Project Components
The project consists of three main components:
- Arduino Code: Responsible for reading sensor data from MPU6050 and HMC5883L sensors and transmitting it to the server via WiFi and UDP.
- Python Script: Acts as the server to receive sensor data from Arduino and sends it to Blender using a custom protocol.
- Blender Plugin: Provides a user interface in Blender for configuring the server settings and starting/stopping data streaming.

### 1.3 Features
The Motion Tracking Suit project offers the following features:
- Real-time motion tracking with Arduino-based sensors.
- Customizable sensor configurations and calibration.
- Seamless integration with Blender for data visualization.
- User-friendly interface in Blender for server settings.

## 2. Installation

### 2.1 Required Libraries
The Arduino code requires the following libraries:
- Wire.h
- Arduino.h
- ESP8266WiFi.h
- WiFiUdp.h
- Adafruit_MPU6050.h
- Adafruit_HMC5883_U.h
- ArduinoJson.h
- Kalman.h

### 2.2 Hardware Setup
Connect the MPU6050 and HMC5883L sensors to the Arduino board as per the wiring instructions in the Arduino code.

### 2.3 Software Setup
Upload the Arduino code to the Arduino board using the Arduino IDE.

## 3. Arduino Code

### 3.1 Sensor Configuration
The code configures the MPU6050 and HMC5883L sensors with specific settings.

```cpp
// Sensor Configuring
Adafruit_MPU6050 mpu6050;
Adafruit_HMC5883_Unified mag = Adafruit_HMC5883_Unified(12345);

// ... (continued in the next snippet)
```

### 3.2 WiFi and UDP Configuration
The code sets up the WiFi connection and UDP port for data transmission.

```cpp
// Wifi Configuration
char const *ssid = "YourWiFiSSID";
char const *password = "YourWiFiPassword";

// Udp Configuration
WiFiUDP Udp;
char const *udp_ip = "YourServerIPAddress";
int udp_port = 4455;
bool send_json = true;

// ... (continued in the next snippet)
```

### 3.3 Kalman Filter Setup
The code initializes the Kalman filter instances for angle calculation.

```cpp
// Kalman Filter Setup
Kalman kalmanX, kalmanY, kalmanZ; // Create the Kalman instances

// ... (continued in the next snippet)
```

### 3.4 Magnetometer Calibration
The code calibrates the magnetometer to improve accuracy.

```cpp
// Magnet

ometer Calibration
#define MAG0MAX 603
#define MAG0MIN -578

#define MAG1MAX 542
#define MAG1MIN -701

#define MAG2MAX 547
#define MAG2MIN -556

float magOffset[3] = {(MAG0MAX + MAG0MIN) / 2, (MAG1MAX + MAG1MIN) / 2, (MAG2MAX + MAG2MIN) / 2};
double magGain[3];

// ... (continued in the next snippet)
```

## 4. Sensor Data Update

### 4.1 Updating Sensor Data
The code updates the sensor data, including acceleration, gyroscope, temperature, and magnetometer readings.

```cpp
// Update all the IMU values
updateMPU6050();
updateHMC5883L();

// ... (continued in the next snippet)
```

### 4.2 Updating MPU6050 Sensor Data
The code reads the accelerometer and gyroscope data from the MPU6050 sensor.

```cpp
void updateMPU6050()
{
    sensors_event_t a, g, temp;
    mpu6050.getEvent(&a, &g, &temp);

    accX = a.acceleration.x;
    accY = a.acceleration.y;
    accZ = a.acceleration.z;

    tempRaw = temp.temperature;

    gyroX = g.gyro.x;
    gyroY = g.gyro.y;
    gyroZ = g.gyro.z;
}
```

### 4.3 Updating HMC5883L Sensor Data
The code reads the magnetometer data from the HMC5883L sensor.

```cpp
void updateHMC5883L()
{
    sensors_event_t event;
    mag.getEvent(&event);

    magX = event.magnetic.x;
    magY = event.magnetic.y;
    magZ = event.magnetic.z;

    // ... (continued in the next snippet)
```

### 4.4 Setting Motion Detection Threshold and Duration for MPU6050
The code sets the motion detection threshold and duration for the MPU6050 sensor.

```cpp
mpu6050.setMotionDetectionThreshold(1);
mpu6050.setMotionDetectionDuration(20);
```

### 4.5 Enabling Motion Interrupt for MPU6050
The code enables the motion interrupt for the MPU6050 sensor.

```cpp
mpu6050.setInterruptPinLatch(true);
mpu6050.setInterruptPinPolarity(true);
mpu6050.setMotionInterrupt(true);
```

### 4.6 Initializing Kalman Filter Angles (kalAngleX, kalAngleY, kalAngleZ)
The code initializes the Kalman filter angles for roll, pitch, and yaw.

```cpp
kalmanX.setAngle(roll); // First set roll starting angle
gyroXangle = roll;
compAngleX = roll;

kalmanY.setAngle(pitch); // Then pitch
gyroYangle = pitch;
compAngleY = pitch;

kalmanZ.setAngle(yaw); // And finally yaw
gyroZangle = yaw;
compAngleZ = yaw;
```

## 5. UDP Data Sending

### 5.1 JSON Data Serialization (sensorGetJson())
The code serializes sensor data into JSON format.

```cpp
String sensorGetJson()
{
    updateSensor();
    StaticJsonDocument<1024> static_json_document;

    // Get acceleration values
    int axis[3] = {roll, pitch, yaw};
    calculateAxis(axis);
    static_json_document["roll"] = axis[0];
    static_json_document["pitch"] = axis[1];
    static_json_document["yaw"] = axis[2];

    char doc_buffer[1024];
    serializeJson(static_json_document, doc_buffer);

    return String(doc_buffer);
}
```

### 5.2 Sending UDP Data (udpSend())
The code sends the serialized JSON data via UDP.

```cpp
void udpSend(String message, int delay_ms)
{
    Udp.beginPacket(udp_ip, udp_port);
    Udp.write(message.c_str());
    Udp.endPacket();
    Serial.printf("Sending packet: %s\n", message.c_str());
    delay(delay_ms);
}
```

## 6. User Interface in Blender

### 6.1 Blender Plugin Overview
The Blender plugin provides a user interface for configuring the server settings and controlling data streaming.

### 6.2 Server Configuration Panel (SERMOTIONS_PT_server)
The server configuration panel allows users to set the IP address and port for data transmission.

```python
class SERMOTIONS_PT_server(bpy.types.Panel):
    bl_idname = "SERMOTIONS_PT_server"
    bl_label = "Server Configuration"
    bl_category = "Sermotions"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"

    def draw(self, context):
        layout = self.layout
        scene = context.scene
        props = scene.props

        layout.prop(props, "ip")
        layout.prop(props, "port")

        # ... (continued in the next snippet)
```

### 6.3 Blender Operators for Start and Save (OT_start, OT_save)
The Blender operators handle the events for starting and saving server configurations.

```python
class SERMOTIONS_PT_server(bpy.types.Panel):
    # ... (previous code)

    class OT_save(bpy.types.Operator):
        bl_label = "Save"
        bl_idname = "sermotions.save"

        def execute(self, context):
            config.write()
            SERMOTIONS_PT_server.status_print(self, "Server configuration is saved.")
            return {"FINISHED"}

    class OT_start(bpy.types.Operator):
        bl_label = "Start"
        bl_idname = "sermotions.start"

        def execute(self, context):
            global proc_server
            if not proc_server.is_alive():
                proc_server.start()
                SERMOTIONS_PT_server.status_print(self, "Server started.")
                print_debug("UDP server started.")
            else:
                proc_server.terminate()
                SERMOTIONS_PT_server.status_print(self, "Server stopped.")
                proc_server = create_process_server()
                print_debug("UDP server stopped.")
            return {"FINISHED"}

    # ... (continued in the next snippet)
```

### 6.4 Blender Panel Registration (register(), unregister())
The register and unregister functions are used to add the server configuration panel to Blender's user interface.

```python
def register():
    bpy.utils.register_class(SERMOTIONS_PT_main)
    bpy.utils.register_class(SERMOTIONS_PT_server)
    bpy.utils.register_class(SERMOTIONS_PT_server.OT_save)
    bpy.utils.register_class(SERMOTIONS_PT_server.OT_start)
    bpy.types.Scene.server_status = bpy.props.StringProperty()

    bpy.types.Scene.props = bpy.props.PointerProperty(type=SERMOTIONS_PT_server.PT)

def unregister():
    bpy.utils.unregister_class(SERMOTIONS_PT_main)
    bpy.utils.unregister_class(SERMOTIONS_PT_server)
    bpy.utils.unregister_class(SERMOTIONS_PT_server.OT_save)
    bpy.utils.unregister_class(SERMOTIONS_PT_server.OT_start)
    del bpy.types.Scene.server_status
    del bpy.types.Scene.props
```

## 7. Main Function and Execution

### 7.1 Plugin Registration (register(), unregister())
The register and unregister functions

 are the main entry points for the Blender plugin.

```python
if __name__ == "__main__":
    register()
```

### 7.2 Main Execution for Blender Plugin
The plugin's main execution handles the registration of panels and operators in Blender.

```python
def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
```

## 8. Unreal Engine Integration

### 8.1 Overview
The Motion Tracking Suit can also be integrated with Unreal Engine to enable real-time motion tracking within the engine.

### 8.2 Installing the Plugin
To integrate the Motion Tracking Suit with Unreal Engine, follow these steps:
1. Download the Motion Tracking Suit plugin from the GitHub repository.
2. Copy the plugin files into the "Plugins" folder of your Unreal Engine project.
3. Open your Unreal Engine project, and the plugin will be automatically detected and enabled.

### 8.3 Configuring Motion Tracking Suit
Before using the plugin in Unreal Engine, configure the server settings as follows:
1. Open the "Plugins" window in Unreal Engine.
2. Locate the "Motion Tracking Suit" plugin and click on it to open its settings.
3. Enter the IP address and port number used by the Arduino server.
4. Save the settings.

### 8.4 Usage and Integration with Unreal Engine
After configuring the plugin, you can start using the Motion Tracking Suit within your Unreal Engine project:
1. Create a new Blueprint or open an existing one.
2. Search for the "Motion Tracking Suit" nodes and functions in the Blueprint editor.
3. Use the nodes to access the real-time motion tracking data from the Arduino sensors.
4. Integrate the motion data into your game or simulation to control characters or objects based on real-world motion.

## 9. Folder Structure
Sure! Here is the folder structure for an electronics project:

```
electronics_project/
├── doc/
│   ├── datasheets/
│   │   ├── datasheet1.pdf
│   │   └── datasheet2.pdf
│   ├── schematics/
│   │   ├── schematic1.pdf
│   │   └── schematic2.pdf
│   └── documentation.pdf
├── src/
│   ├── arduino/
│   │   └── main.ino
│   ├── raspberry_pi/
│   │   └── main.py
│   └── ...
├── pcb/
│   ├── gerber_files/
│   │   ├── layer1.ger
│   │   ├── layer2.ger
│   │   └── ...
│   ├── bom.csv
│   └── pcb_design.pdf
├── simulations/
│   ├── spice/
│   │   ├── circuit1.sp
│   │   └── circuit2.sp
│   └── ...
├── datasheets/
│   ├── sensor1.pdf
│   ├── microcontroller.pdf
│   └── ...
├── images/
│   ├── image1.png
│   └── image2.png
├── firmware/
│   ├── firmware_v1.bin
│   └── firmware_v2.bin
├── simulations/
│   ├── spice/
│   │   ├── circuit1.sp
│   │   └── circuit2.sp
│   └── ...
├── tests/
│   ├── test1.py
│   └── test2.py
├── libraries/
│   ├── arduino_lib1/
│   ├── arduino_lib2/
│   └── ...
├── .gitignore
├── LICENSE
└── README.md
```

This folder structure is an example for an electronics project:

- `doc` folder contains the project documentation. It includes datasheets, schematics, and project documentation in PDF format.
- `src` folder contains the source code for microcontrollers or microprocessors. For example, the Arduino code can be placed in the `arduino` subfolder, and the Raspberry Pi code can be placed in the `raspberry_pi` subfolder.
- `pcb` folder contains the files related to PCB design. Gerber files, Bill of Materials (BOM) in CSV format, and the PCB design document can be included in this folder.
- `simulations` folder is used for electronic circuit simulations. SPICE or other simulation files can be placed in this folder.
- `datasheets` folder contains datasheets for sensors, microcontrollers, and other components used in the project.
- `images` folder includes images and visuals related to the project.
- `firmware` folder contains firmware files.
- `tests` folder is used for project tests. Test scripts can be placed in this folder.
- `libraries` folder contains external libraries used in the project.
- `.gitignore` file specifies files that should not be uploaded to version control (e.g., Git).
- `LICENSE` file specifies the project's license.
- `README.md` file provides general information about the project.

This folder structure serves as a starting point for electronics projects and can be customized based on the components, platforms, and tools used in your specific project.

## 10. Conclusion

### 10.1 Summary
The Motion Tracking Suit project provides a powerful motion tracking solution using Arduino-based sensors and visualization in Blender and Unreal Engine. By combining these technologies, it offers a versatile solution for motion capture and control in various applications, including animation, game development, virtual reality experiences, and more.

### 10.2 Acknowledgments
Special thanks to [Your Name] for their contributions to this project.

### 10.3 License
This project is licensed under [License Name]. See the [LICENSE](link-to-license) file for more information.

### 10.4 Contact Information
For inquiries or support, please contact [Your Email Address].

Thank you for using the Motion Tracking Suit project! If you have any questions or feedback, please don't

 hesitate to reach out. Happy motion tracking!
